import fs from "fs/promises";
import { parse } from "recast";
import { initFilePath, initJsxFilePath } from "../consts";
import type { Config } from "./setup-config";

/**
 * Sets up the `.flowbite-react/init.tsx` file in the project.
 *
 * This function ensures the init.tsx file exists and is up-to-date with the current configuration.
 * It will create or update the file if needed.
 */
export async function setupInit(config: Config) {
  const content = `
/* eslint-disable */
// @ts-nocheck
// biome-ignore-all lint: auto-generated file

// This file is auto-generated by the flowbite-react CLI.
// Do not edit this file directly.
// Instead, edit the .flowbite-react/config.json file.

import { StoreInit } from "flowbite-react/store/init";
import React from "react";

export const config = {
  dark: ${config.dark},
  prefix: "${config.prefix}",
  version: ${config.version},
};

export function ThemeInit() {
  return <StoreInit {...config} />;
}

ThemeInit.displayName = "ThemeInit";
`.trim();

  const targetPath = config.tsx ? initFilePath : initJsxFilePath;
  const oldPath = config.tsx ? initJsxFilePath : initFilePath;

  try {
    let currentContent = "";
    try {
      currentContent = await fs.readFile(targetPath, "utf-8");
    } catch {
      console.log(`Creating ${targetPath} file...`);
      setTimeout(() => fs.writeFile(targetPath, content), 10);
    }

    if (currentContent) {
      const currentAst = parse(currentContent);
      const newAst = parse(content);

      if (!compareNodes(currentAst.program, newAst.program)) {
        console.log(`Updating ${targetPath} file...`);
        setTimeout(() => fs.writeFile(targetPath, content), 10);
      }
    }

    try {
      await fs.access(oldPath);
      console.log(`Removing ${oldPath} file...`);
      await fs.unlink(oldPath);
    } catch {
      // noop
    }
  } catch (error) {
    console.error(`Failed to update ${targetPath}:`, error);
  }
}

/**
 * Compare two AST nodes ignoring location info and comments
 */
function compareNodes(a: unknown, b: unknown): boolean {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }
    return a.every((item, i) => compareNodes(item, b[i]));
  }
  if (typeof a !== "object" || typeof b !== "object") {
    return a === b;
  }

  // Skip location and comment-related properties
  const keysA = Object.keys(a).filter(
    (k) => !["start", "end", "loc", "range", "tokens", "comments", "leadingComments", "trailingComments"].includes(k),
  );
  const keysB = Object.keys(b).filter(
    (k) => !["start", "end", "loc", "range", "tokens", "comments", "leadingComments", "trailingComments"].includes(k),
  );

  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every((key) => compareNodes(a[key as keyof typeof a], b[key as keyof typeof b]));
}
